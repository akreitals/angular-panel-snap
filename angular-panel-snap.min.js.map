{"version":3,"sources":["module.js","menu.js","angular-panel-snap.min.js","panel-group.js","panel.js","scroll.js"],"names":["angular","module","akPanelGroupMenu","$rootScope","$log","restrict","template","scope","for","link","isDefined","panels","$on","event","data","group","stopPropagation","panel","id","name","active","push","forEach","select","$emit","error","directive","$inject","akPanelGroup","replace","controller","speed","threshold","fullWindow","keyboard","prevKey","nextKey","snap","init","panelGroupController","$scope","$element","$attrs","$window","$timeout","$document","bind","ctrl","eventContainer","on","scrollFn","enabled","e","preventDefault","isSnapping","type","delta","Math","max","min","originalEvent","wheelDelta","detail","snapToPanel","currentPanel","element","resize","keydown","which","cancel","scrollTimeout","scrollStop","resizeTimeout","scrollInterval","isNaN","container","innerHeight","clientHeight","target","offset","snapContainer","scrollTop","round","length","activatePanel","scrollDifference","scrollOffset","maxOffset","scrollHeight","floor","ceil","$broadcast","onLeave","scrollTarget","scrollTo","then","onEnter","setActive","this","addPanel","panelScope","panelName","enableSnap","disableSnap","toggleSnap","snapTo","documentElement","document","unbind","akPanel","require","transclude","attrs","css","width","height","position","scrollEasing","x","pow","runFn","$q","cancelAnimation","requestAnimation","proto","prototype","isDocument","el","HTMLDocument","nodeType","DOCUMENT_NODE","isElement","HTMLElement","ELEMENT_NODE","unwrap","left","top","duration","aliasFn","scrollToElement","scrollToAnimated","apply","arguments","scrollLeft","easing","scrollAnimation","deferred","startLeft","startTop","deltaLeft","deltaTop","startTime","cancelOnEvents","cancelScrollAnimation","$event","reject","defer","resolve","promise","animationStep","timestamp","progress","percent","getBoundingClientRect","overloaders","value","isNumber","scrollX","body","scrollY","overloadScrollPos","superFn","overloadFn","methodName","polyfill","vendors","fnName","fallback","key","suffix","substr","toUpperCase","i","lastTime","callback","currTime","Date","getTime","timeToCall","run","factory"],"mappings":"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","file":"angular-panel-snap.min.js","sourcesContent":["(function() {\n'use strict';\n\n/*\n * angular-panel-snap main module definition\n */\nangular.module('panel-snap', []);\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel-group-menu directive\n *\n * Creates a menu for the referenced ak-panel-group container\n *\n * @attribute for (required) String: name attribute of the ak-panel-group the menu is to reference\n */\nangular\n  .module('panel-snap')\n  .directive('akPanelGroupMenu', akPanelGroupMenu);\n\n/* @ngInject */\nfunction akPanelGroupMenu ($rootScope, $log) {\n  return {\n    restrict: 'EA',\n    template: '<ul class=\"ak-menu\"><li ng-repeat=\"panel in panels\" ng-class=\"{active: panel.active}\" ng-click=\"select(panel.id)\"><a href>{{panel.name}}</a></li></ul>',\n    scope: {\n      for: '@'\n    },\n    link: function (scope) {\n      if (!angular.isDefined(scope.for)) {\n        $log.error(\"PanelGroupMenu: no 'for' attribute provided\");\n        return;\n      }\n\n      scope.panels = [];\n\n      /*\n       * listen for addedPanel event, if group name matches then add\n       * it to the menu\n       */\n      $rootScope.$on('panelsnap:addedPanel', function (event, data) {\n        if (scope.for === data.group) {\n          event.stopPropagation();\n          var panel = {\n            id: data.id,\n            name: data.name,\n            active: false\n          };\n          scope.panels.push(panel);\n        }\n      });\n\n      /*\n       * listen for activatePanel event, if group name matches then set\n       * active flag target menu element\n       */\n      $rootScope.$on('panelsnap:activatePanel', function (event, data) {\n        if (scope.for === data.group) {\n          event.stopPropagation();\n          angular.forEach(scope.panels, function (panel) {\n            panel.active = false;\n          });\n          scope.panels[data.id].active = true;\n        }\n      });\n\n      /*\n       * emit event to tell ak-panel-group directive to select the target panel\n       */\n      scope.select = function (id) {\n        $rootScope.$emit('panelsnap:selectPanel', {group: scope.for, id: id});\n      };\n    }\n  };\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * angular-panel-snap main module definition\n */\nangular.module('panel-snap', []);\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel-group-menu directive\n *\n * Creates a menu for the referenced ak-panel-group container\n *\n * @attribute for (required) String: name attribute of the ak-panel-group the menu is to reference\n */\nangular\n  .module('panel-snap')\n  .directive('akPanelGroupMenu', akPanelGroupMenu);\n\n/* @ngInject */\nfunction akPanelGroupMenu ($rootScope, $log) {\n  return {\n    restrict: 'EA',\n    template: '<ul class=\"ak-menu\"><li ng-repeat=\"panel in panels\" ng-class=\"{active: panel.active}\" ng-click=\"select(panel.id)\"><a href>{{panel.name}}</a></li></ul>',\n    scope: {\n      for: '@'\n    },\n    link: function (scope) {\n      if (!angular.isDefined(scope.for)) {\n        $log.error(\"PanelGroupMenu: no 'for' attribute provided\");\n        return;\n      }\n\n      scope.panels = [];\n\n      /*\n       * listen for addedPanel event, if group name matches then add\n       * it to the menu\n       */\n      $rootScope.$on('panelsnap:addedPanel', function (event, data) {\n        if (scope.for === data.group) {\n          event.stopPropagation();\n          var panel = {\n            id: data.id,\n            name: data.name,\n            active: false\n          };\n          scope.panels.push(panel);\n        }\n      });\n\n      /*\n       * listen for activatePanel event, if group name matches then set\n       * active flag target menu element\n       */\n      $rootScope.$on('panelsnap:activatePanel', function (event, data) {\n        if (scope.for === data.group) {\n          event.stopPropagation();\n          angular.forEach(scope.panels, function (panel) {\n            panel.active = false;\n          });\n          scope.panels[data.id].active = true;\n        }\n      });\n\n      /*\n       * emit event to tell ak-panel-group directive to select the target panel\n       */\n      scope.select = function (id) {\n        $rootScope.$emit('panelsnap:selectPanel', {group: scope.for, id: id});\n      };\n    }\n  };\n}\nakPanelGroupMenu.$inject = [\"$rootScope\", \"$log\"];\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel-group directive\n *\n * Container for set of 'ak-panel' directives that maintains the panels state and all interactions with the group\n *\n * @attribute name (optional) String: name of the group, to be referenced in ak-panel-group-menu's 'for' attribute\n * @attribute speed (optional) Number: duration in milliseconds to snap to the desired panel, defaults to 400ms\n * @attribute threshold (optional) Number: amount of pixels required to scroll before snapping to the next panel, defults to 50px\n * @attribute fullWindow (optional) Boolean: true if the panels are to fill the full browser window\n * @attribute keyboard (optional) Boolean: true if key presses can be used to navigate panels\n * @attribute prevKey (optional) Number: keyCode of key to navigate to previous panel, defaults to 38 (up arrow)\n * @attribute nextKey (optional) Number: keyCode of key to navigate to next panel, defaults to 40 (down arrow)\n * @attribute snap (optional) Boolean: enable or disable the snapping on initialization\n */\nangular\n  .module('panel-snap')\n  .directive('akPanelGroup', akPanelGroup)\n  .controller('PanelGroupController', panelGroupController);\n\n/* @ngInject */\nfunction akPanelGroup () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    controller: 'PanelGroupController',\n    scope: {\n      name: '@',\n      speed: '=',\n      threshold: '=',\n      fullWindow: '=',\n      keyboard: '=',\n      prevKey: '=',\n      nextKey: '=',\n      snap: '='\n    },\n    link: function (scope) {\n      // Call init after child panels have registered with the controller\n      scope.init();\n    }\n  };\n}\n\n/* @ngInject */\nfunction panelGroupController ($scope, $element, $attrs, $window, $timeout, $document, $rootScope) {\n  var ctrl = this;\n\n  var resizeTimeout;\n  var scrollTimeout;\n\n  ctrl.panels = [];\n\n  ctrl.currentPanel = 0;\n  ctrl.scrollInterval = 0;\n  ctrl.scrollOffset = 0;\n  ctrl.isSnapping = false;\n  ctrl.enabled = true;\n\n  ctrl.speed = 400;   // default snap animation duration in milliseconds\n  ctrl.threshold = 50;  // default pixel threshold for snap to occur in pixels\n  ctrl.prevKey = 38;    // default prevKey key code - up arrow\n  ctrl.nextKey = 40;    // default nextKey key code - down arrow\n\n  /*\n   * add a panels scope to the panels array\n   * - attached to `this` so it can be called from child panel directives\n   */\n  ctrl.addPanel = function (panelScope) {\n    var panelName = angular.isDefined(panelScope.name) ? panelScope.name : 'Panel ' + (ctrl.panels.length + 1);\n    ctrl.panels.push(panelScope);\n    if (angular.isDefined($scope.name)) {\n      $rootScope.$emit('panelsnap:addedPanel', { group: $scope.name, name: panelName, id: ctrl.panels.length-1 });\n    }\n  };\n\n  /*\n   * enable snapping\n   */\n  ctrl.enableSnap = function () {\n    // TODO: should this snap to closest panel when enabled? (yes)\n    ctrl.enabled = true;\n  };\n\n  /*\n   * disable snapping\n   */\n  ctrl.disableSnap = function () {\n    ctrl.enabled = false;\n  };\n\n  /*\n   * toggle snapping\n   */\n  ctrl.toggleSnap = function () {\n    ctrl.enabled = !ctrl.enabled;\n  };\n\n  /*\n   * toggle snapping\n   */\n  ctrl.snapTo = function (id) {\n    snapToPanel(id);\n  };\n\n  /*\n   * initialise the controller state\n   * - called from the directive link function. This ensures it is called after any child panels\n   *  link function has called addPanel and therefore the panels array is filled and valid.\n   */\n  $scope.init = function () {\n    ctrl.container = $element;\n    ctrl.eventContainer = ctrl.container;\n    ctrl.snapContainer = ctrl.container;\n\n    // if full window, bind and snap using document instead of element\n    if ($scope.fullWindow) {\n      ctrl.container = angular.element($document[0].documentElement);\n      ctrl.eventContainer = ctrl.snapContainer = $document;\n    }\n\n    // set options / variables\n    ctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n    ctrl.speed = angular.isDefined($scope.speed) ? $scope.speed : ctrl.speed;\n    ctrl.threshold = angular.isDefined($scope.threshold) ? $scope.threshold : ctrl.threshold;\n    ctrl.prevKey = angular.isDefined($scope.prevKey) ? $scope.prevKey : ctrl.prevKey;\n    ctrl.nextKey = angular.isDefined($scope.nextKey) ? $scope.nextKey : ctrl.nextKey;\n    ctrl.enabled = angular.isDefined($scope.snap) ? $scope.snap : ctrl.enabled;\n\n    bind();\n    $timeout(function() {\n      activatePanel(ctrl.currentPanel);\n    },0);\n  };\n\n  /*\n   * listen for selectPanel event, if group name matches then snap\n   * to the target panel\n   */\n  $rootScope.$on('panelsnap:selectPanel', function (event, data) {\n    if ($scope.name === data.group) {\n      event.stopPropagation();\n      snapToPanel(data.id);\n    }\n  });\n\n  $scope.$on('$destroy',function(){\n    angular.element(document).unbind('.panelsnap');\n  });\n\n  function bind() {\n    // bind scrolling events\n    ctrl.eventContainer.on('scroll.panelsnap', scrollFn);\n\n    // bind scrolling events\n    if(ctrl.enabled) {\n      ctrl.eventContainer.on('mousewheel.panelsnap touchmove.panelsnap DOMMouseScroll.panelsnap', function(e) {\n        e.preventDefault();\n        if(ctrl.isSnapping) return false;\n        if(e.type==='mousewheel'||e.type==='DOMMouseScroll') {\n          var delta = Math.max(-1, Math.min(1, (e.originalEvent.wheelDelta || -e.originalEvent.detail)));\n          if(delta && delta >0) snapToPanel(ctrl.currentPanel - 1);\n          else if(delta) snapToPanel(ctrl.currentPanel + 1);\n        }\n      });\n    }\n\n    // bind resize event\n    angular.element($window).on('resize.panelSnap', resize);\n\n    // bind keyboard events\n    if ($scope.keyboard) {\n      angular.element($window).on('keydown.panelSnap', keydown);\n    }\n  }\n\n  function keydown(e) {\n    if (!ctrl.enabled) {\n      return;\n    }\n\n    // prevent any keypress events while snapping\n    if (ctrl.isSnapping) {\n      if (e.which === ctrl.prevKey || e.which === ctrl.nextKey) {\n        e.preventDefault();\n        return false;\n      }\n      return;\n    }\n\n    switch (e.which) {\n      case ctrl.prevKey:\n        e.preventDefault();\n        snapToPanel(ctrl.currentPanel - 1);\n        break;\n      case ctrl.nextKey:\n        e.preventDefault();\n        snapToPanel(ctrl.currentPanel + 1);\n        break;\n    }\n  }\n\n  function scrollFn(e) {\n    var threshold = 50;\n    $timeout.cancel(scrollTimeout);\n    scrollTimeout = $timeout(function () {\n      scrollStop(e);\n    }, threshold);\n  }\n\n  function resize() {\n    var threshold = 150;\n    $timeout.cancel(resizeTimeout);\n    resizeTimeout = $timeout(function () {\n      ctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\n      if (!ctrl.enabled) {\n        return;\n      }\n\n      // snap back to current panel after resizing\n      snapToPanel(ctrl.currentPanel);\n    }, threshold);\n  }\n\n  function scrollStop(e) {\n    e.stopPropagation();\n\n    // if (ctrl.isMouseDown) {\n    //  return;\n    // }\n\n    if (ctrl.isSnapping) {\n      return;\n    }\n\n    var target;\n    var offset = ctrl.snapContainer.scrollTop();\n\n    if (!ctrl.enabled) {\n      // still want to activate the correct panel even if snapping is disabled\n      target = Math.max(0, Math.min(Math.round(offset / ctrl.scrollInterval), ctrl.panels.length - 1));\n      if (target !== ctrl.currentPanel) {\n        activatePanel(target);\n      }\n      return;\n    }\n\n    var scrollDifference = offset - ctrl.scrollOffset;\n    var maxOffset = ctrl.container[0].scrollHeight - ctrl.scrollInterval;\n\n    // determine target panel\n    if (scrollDifference < -ctrl.threshold && scrollDifference > -ctrl.scrollInterval) {\n      target = Math.floor(offset / ctrl.scrollInterval);\n    } else if (scrollDifference > ctrl.threshold && scrollDifference < ctrl.scrollInterval) {\n      target = Math.ceil(offset / ctrl.scrollInterval);\n    } else {\n      target = Math.round(offset / ctrl.scrollInterval);\n    }\n\n    // ensure target is within panel array bounds\n    target = Math.max(0, Math.min(target, ctrl.panels.length - 1));\n\n    if (scrollDifference === 0) {\n      // Do nothing\n    } else if (offset <= 0 || offset >= maxOffset) {\n      // only activate to prevent stuttering\n      activatePanel(target);\n      // set a scrollOffset to a sane number for next scroll\n      ctrl.scrollOffset = offset <= 0 ? 0 : maxOffset;\n    } else {\n      snapToPanel(target);\n    }\n  }\n\n  function snapToPanel(target) {\n    if (isNaN(target) || target < 0 || target >= ctrl.panels.length) {\n      return;\n    }\n\n    ctrl.isSnapping = true;\n\n    $rootScope.$broadcast('panelsnap:start', { group: $scope.name, id: target });\n    $timeout(function() { // lets the broadcast get processed before continuing\n      ctrl.panels[ctrl.currentPanel].onLeave();\n\n      var scrollTarget = ctrl.scrollInterval * target;\n      ctrl.snapContainer.scrollTo(0, scrollTarget, ctrl.speed).then(function () {\n        ctrl.scrollOffset = scrollTarget;\n        $timeout(function(){\n          ctrl.isSnapping = false;\n        },300);\n\n\n        $rootScope.$broadcast('panelsnap:finish', { group: $scope.name, id: target });\n        ctrl.panels[target].onEnter();\n\n        activatePanel(target);\n      });\n    },0);\n  }\n\n  function activatePanel(target) {\n    // if no panels, or panels have not yet loaded (within ng-repeat) return\n    if (!ctrl.panels || ctrl.panels.length < 1) {\n      return;\n    }\n\n    angular.forEach(ctrl.panels, function (panel) {\n      panel.setActive(false);\n    });\n    ctrl.panels[target].setActive(true);\n    ctrl.currentPanel = target;\n\n    // TODO: call onActivate function for target\n    $rootScope.$broadcast('panelsnap:activate', {group: $scope.name, id: target });\n    $rootScope.$emit('panelsnap:activatePanel', { group: $scope.name, id: target });\n  }\n}\npanelGroupController.$inject = [\"$scope\", \"$element\", \"$attrs\", \"$window\", \"$timeout\", \"$document\", \"$rootScope\"];\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel directive\n *\n * Creates a panel inside an ak-panel-group directive. Must be a child of an ak-panel-group element.\n *\n * @attribute name (optional) String: name of panel, will form text of nav element in any ak-panel-group-menu's assocaited with the containing group\n * @attribute onEnter (optional) Function: function to be called when panel is snapped into\n * @attribute onLeave (optional) Function: function to be called when panel is snapped out of\n */\nangular\n  .module('panel-snap')\n  .directive('akPanel', akPanel);\n\n/* @ngInject */\nfunction akPanel () {\n  return {\n    restrict: 'EA',\n    require: '^akPanelGroup',\n    replace: true,\n    transclude: true,\n    scope: {\n      name: '@',\n      onEnter: '&',\n      onLeave: '&'\n    },\n    template: '<div class=\"ak-panel\" ng-class=\"{active: active}\" ng-transclude></div>',\n    link: function (scope, element, attrs, ctrl) {\n\n      // add to parent ak-panel-group\n      ctrl.addPanel(scope);\n\n      // default panel styles\n      element.css({\n        'width': '100%',\n        'height': '100%',\n        'position': 'relative'\n      });\n\n      // attach enable/disable scroll methods to scope - need be accessed by $parent due to transclude scope\n      scope.enableSnap = ctrl.enableSnap;\n      scope.disableSnap = ctrl.disableSnap;\n      scope.toggleSnap = ctrl.toggleSnap;\n      scope.snapTo = ctrl.snapTo;\n\n      // active flag and getter function, to set class .active on panel\n      scope.active = false;\n      scope.setActive = function (active) {\n        scope.active = active;\n      };\n    }\n  };\n}\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * Scroll methods - removes the need for external jQuery or GreenSock libraries\n *\n * Adapted from durated's Angular Scroll module\n * https://github.com/durated/angular-scroll\n */\nangular\n  .module('panel-snap')\n  .value('scrollEasing', scrollEasing)\n  .run(runFn)\n  .factory('polyfill', polyfill)\n  .factory('requestAnimation', requestAnimation)\n  .factory('cancelAnimation', cancelAnimation);\n\nfunction scrollEasing (x) {\n  if(x < 0.5) {\n    return Math.pow(x*2, 2)/2;\n  }\n  return 1-Math.pow((1-x)*2, 2)/2;\n}\n\n/* @ngInject */\nfunction runFn ($window, $q, cancelAnimation, requestAnimation, scrollEasing) {\n  var proto = angular.element.prototype;\n\n  var isDocument = function(el) {\n    return (typeof HTMLDocument !== 'undefined' && el instanceof HTMLDocument) || (el.nodeType && el.nodeType === el.DOCUMENT_NODE);\n  };\n\n  var isElement = function(el) {\n    return (typeof HTMLElement !== 'undefined' && el instanceof HTMLElement) || (el.nodeType && el.nodeType === el.ELEMENT_NODE);\n  };\n\n  var unwrap = function(el) {\n    return isElement(el) || isDocument(el) ? el : el[0];\n  };\n\n  proto.scrollTo = function(left, top, duration) {\n    var aliasFn;\n    if(angular.isElement(left)) {\n      aliasFn = this.scrollToElement;\n    } else if(duration) {\n      aliasFn = this.scrollToAnimated;\n    }\n    if(aliasFn) {\n      return aliasFn.apply(this, arguments);\n    }\n    var el = unwrap(this);\n    if(isDocument(el)) {\n      return $window.scrollTo(left, top);\n    }\n    el.scrollLeft = left;\n    el.scrollTop = top;\n  };\n\n  proto.scrollToAnimated = function(left, top, duration, easing) {\n    var scrollAnimation, deferred;\n    if(duration && !easing) {\n      easing = scrollEasing;\n    }\n    var startLeft = this.scrollLeft(),\n      startTop = this.scrollTop(),\n      deltaLeft = Math.round(left - startLeft),\n      deltaTop = Math.round(top - startTop);\n\n    var startTime = null;\n    var el = this;\n\n    var cancelOnEvents = 'scroll mousedown mousewheel touchmove keydown';\n    var cancelScrollAnimation = function($event) {\n      if (!$event || $event.which > 0) {\n        el.unbind(cancelOnEvents, cancelScrollAnimation);\n        cancelAnimation(scrollAnimation);\n        deferred.reject();\n        scrollAnimation = null;\n      }\n    };\n\n    if(scrollAnimation) {\n      cancelScrollAnimation();\n    }\n    deferred = $q.defer();\n\n    if(!deltaLeft && !deltaTop) {\n      deferred.resolve();\n      return deferred.promise;\n    }\n\n    var animationStep = function(timestamp) {\n      if (startTime === null) {\n        startTime = timestamp;\n      }\n\n      var progress = timestamp - startTime;\n      var percent = (progress >= duration ? 1 : easing(progress/duration));\n\n      el.scrollTo(\n        startLeft + Math.ceil(deltaLeft * percent),\n        startTop + Math.ceil(deltaTop * percent)\n      );\n      if(percent < 1) {\n        scrollAnimation = requestAnimation(animationStep);\n      } else {\n        el.unbind(cancelOnEvents, cancelScrollAnimation);\n        scrollAnimation = null;\n        deferred.resolve();\n      }\n    };\n\n    //Fix random mobile safari bug when scrolling to top by hitting status bar\n    el.scrollTo(startLeft, startTop);\n\n    // el.bind(cancelOnEvents, cancelScrollAnimation);\n\n    scrollAnimation = requestAnimation(animationStep);\n    return deferred.promise;\n  };\n\n  proto.scrollToElement = function(target, offset, duration, easing) {\n    var el = unwrap(this);\n    var top = this.scrollTop() + unwrap(target).getBoundingClientRect().top - (offset || 0);\n    if(isElement(el)) {\n      top -= el.getBoundingClientRect().top;\n    }\n    return this.scrollTo(0, top, duration, easing);\n  };\n\n  var overloaders = {\n    scrollLeft: function(value, duration, easing) {\n      if(angular.isNumber(value)) {\n        return this.scrollTo(value, this.scrollTop(), duration, easing);\n      }\n      var el = unwrap(this);\n      if(isDocument(el)) {\n        return $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft;\n      }\n      return el.scrollLeft;\n    },\n    scrollTop: function(value, duration, easing) {\n      if(angular.isNumber(value)) {\n        return this.scrollTo(this.scrollTop(), value, duration, easing);\n      }\n      var el = unwrap(this);\n      if(isDocument(el)) {\n        return $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop;\n      }\n      return el.scrollTop;\n    }\n  };\n\n  //Add duration and easing functionality to existing jQuery getter/setters\n  var overloadScrollPos = function(superFn, overloadFn) {\n    return function(value, duration) {\n      if(duration) {\n        return overloadFn.apply(this, arguments);\n      }\n      return superFn.apply(this, arguments);\n    };\n  };\n\n  for(var methodName in overloaders) {\n    proto[methodName] = (proto[methodName] ? overloadScrollPos(proto[methodName], overloaders[methodName]) : overloaders[methodName]);\n  }\n}\nrunFn.$inject = [\"$window\", \"$q\", \"cancelAnimation\", \"requestAnimation\", \"scrollEasing\"];\n\n/* @ngInject */\nfunction polyfill ($window) {\n  var vendors = ['webkit', 'moz', 'o', 'ms'];\n\n  return function(fnName, fallback) {\n    if($window[fnName]) {\n      return $window[fnName];\n    }\n    var suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1);\n    for(var key, i = 0; i < vendors.length; i++) {\n      key = vendors[i]+suffix;\n      if($window[key]) {\n        return $window[key];\n      }\n    }\n    return fallback;\n  };\n}\npolyfill.$inject = [\"$window\"];\n\n/* @ngInject */\nfunction requestAnimation (polyfill, $timeout) {\n  var lastTime = 0;\n  var fallback = function(callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = $timeout(function() {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n\n  return polyfill('requestAnimationFrame', fallback);\n}\nrequestAnimation.$inject = [\"polyfill\", \"$timeout\"];\n\n/* @ngInject */\nfunction cancelAnimation (polyfill, $timeout) {\n  var fallback = function(promise) {\n    $timeout.cancel(promise);\n  };\n\n  return polyfill('cancelAnimationFrame', fallback);\n}\ncancelAnimation.$inject = [\"polyfill\", \"$timeout\"];\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel-group directive\n *\n * Container for set of 'ak-panel' directives that maintains the panels state and all interactions with the group\n *\n * @attribute name (optional) String: name of the group, to be referenced in ak-panel-group-menu's 'for' attribute\n * @attribute speed (optional) Number: duration in milliseconds to snap to the desired panel, defaults to 400ms\n * @attribute threshold (optional) Number: amount of pixels required to scroll before snapping to the next panel, defults to 50px\n * @attribute fullWindow (optional) Boolean: true if the panels are to fill the full browser window\n * @attribute keyboard (optional) Boolean: true if key presses can be used to navigate panels\n * @attribute prevKey (optional) Number: keyCode of key to navigate to previous panel, defaults to 38 (up arrow)\n * @attribute nextKey (optional) Number: keyCode of key to navigate to next panel, defaults to 40 (down arrow)\n * @attribute snap (optional) Boolean: enable or disable the snapping on initialization\n */\nangular\n  .module('panel-snap')\n  .directive('akPanelGroup', akPanelGroup)\n  .controller('PanelGroupController', panelGroupController);\n\n/* @ngInject */\nfunction akPanelGroup () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    controller: 'PanelGroupController',\n    scope: {\n      name: '@',\n      speed: '=',\n      threshold: '=',\n      fullWindow: '=',\n      keyboard: '=',\n      prevKey: '=',\n      nextKey: '=',\n      snap: '='\n    },\n    link: function (scope) {\n      // Call init after child panels have registered with the controller\n      scope.init();\n    }\n  };\n}\n\n/* @ngInject */\nfunction panelGroupController ($scope, $element, $attrs, $window, $timeout, $document, $rootScope) {\n  var ctrl = this;\n\n  var resizeTimeout;\n  var scrollTimeout;\n\n  ctrl.panels = [];\n\n  ctrl.currentPanel = 0;\n  ctrl.scrollInterval = 0;\n  ctrl.scrollOffset = 0;\n  ctrl.isSnapping = false;\n  ctrl.enabled = true;\n\n  ctrl.speed = 400;   // default snap animation duration in milliseconds\n  ctrl.threshold = 50;  // default pixel threshold for snap to occur in pixels\n  ctrl.prevKey = 38;    // default prevKey key code - up arrow\n  ctrl.nextKey = 40;    // default nextKey key code - down arrow\n\n  /*\n   * add a panels scope to the panels array\n   * - attached to `this` so it can be called from child panel directives\n   */\n  ctrl.addPanel = function (panelScope) {\n    var panelName = angular.isDefined(panelScope.name) ? panelScope.name : 'Panel ' + (ctrl.panels.length + 1);\n    ctrl.panels.push(panelScope);\n    if (angular.isDefined($scope.name)) {\n      $rootScope.$emit('panelsnap:addedPanel', { group: $scope.name, name: panelName, id: ctrl.panels.length-1 });\n    }\n  };\n\n  /*\n   * enable snapping\n   */\n  ctrl.enableSnap = function () {\n    // TODO: should this snap to closest panel when enabled? (yes)\n    ctrl.enabled = true;\n  };\n\n  /*\n   * disable snapping\n   */\n  ctrl.disableSnap = function () {\n    ctrl.enabled = false;\n  };\n\n  /*\n   * toggle snapping\n   */\n  ctrl.toggleSnap = function () {\n    ctrl.enabled = !ctrl.enabled;\n  };\n\n  /*\n   * toggle snapping\n   */\n  ctrl.snapTo = function (id) {\n    snapToPanel(id);\n  };\n\n  /*\n   * initialise the controller state\n   * - called from the directive link function. This ensures it is called after any child panels\n   *  link function has called addPanel and therefore the panels array is filled and valid.\n   */\n  $scope.init = function () {\n    ctrl.container = $element;\n    ctrl.eventContainer = ctrl.container;\n    ctrl.snapContainer = ctrl.container;\n\n    // if full window, bind and snap using document instead of element\n    if ($scope.fullWindow) {\n      ctrl.container = angular.element($document[0].documentElement);\n      ctrl.eventContainer = ctrl.snapContainer = $document;\n    }\n\n    // set options / variables\n    ctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n    ctrl.speed = angular.isDefined($scope.speed) ? $scope.speed : ctrl.speed;\n    ctrl.threshold = angular.isDefined($scope.threshold) ? $scope.threshold : ctrl.threshold;\n    ctrl.prevKey = angular.isDefined($scope.prevKey) ? $scope.prevKey : ctrl.prevKey;\n    ctrl.nextKey = angular.isDefined($scope.nextKey) ? $scope.nextKey : ctrl.nextKey;\n    ctrl.enabled = angular.isDefined($scope.snap) ? $scope.snap : ctrl.enabled;\n\n    bind();\n    $timeout(function() {\n      activatePanel(ctrl.currentPanel);\n    },0);\n  };\n\n  /*\n   * listen for selectPanel event, if group name matches then snap\n   * to the target panel\n   */\n  $rootScope.$on('panelsnap:selectPanel', function (event, data) {\n    if ($scope.name === data.group) {\n      event.stopPropagation();\n      snapToPanel(data.id);\n    }\n  });\n\n  $scope.$on('$destroy',function(){\n    angular.element(document).unbind('.panelsnap');\n  });\n\n  function bind() {\n    // bind scrolling events\n    ctrl.eventContainer.on('scroll.panelsnap', scrollFn);\n\n    // bind scrolling events\n    if(ctrl.enabled) {\n      ctrl.eventContainer.on('mousewheel.panelsnap touchmove.panelsnap DOMMouseScroll.panelsnap', function(e) {\n        e.preventDefault();\n        if(ctrl.isSnapping) return false;\n        if(e.type==='mousewheel'||e.type==='DOMMouseScroll') {\n          var delta = Math.max(-1, Math.min(1, (e.originalEvent.wheelDelta || -e.originalEvent.detail)));\n          if(delta && delta >0) snapToPanel(ctrl.currentPanel - 1);\n          else if(delta) snapToPanel(ctrl.currentPanel + 1);\n        }\n      });\n    }\n\n    // bind resize event\n    angular.element($window).on('resize.panelSnap', resize);\n\n    // bind keyboard events\n    if ($scope.keyboard) {\n      angular.element($window).on('keydown.panelSnap', keydown);\n    }\n  }\n\n  function keydown(e) {\n    if (!ctrl.enabled) {\n      return;\n    }\n\n    // prevent any keypress events while snapping\n    if (ctrl.isSnapping) {\n      if (e.which === ctrl.prevKey || e.which === ctrl.nextKey) {\n        e.preventDefault();\n        return false;\n      }\n      return;\n    }\n\n    switch (e.which) {\n      case ctrl.prevKey:\n        e.preventDefault();\n        snapToPanel(ctrl.currentPanel - 1);\n        break;\n      case ctrl.nextKey:\n        e.preventDefault();\n        snapToPanel(ctrl.currentPanel + 1);\n        break;\n    }\n  }\n\n  function scrollFn(e) {\n    var threshold = 50;\n    $timeout.cancel(scrollTimeout);\n    scrollTimeout = $timeout(function () {\n      scrollStop(e);\n    }, threshold);\n  }\n\n  function resize() {\n    var threshold = 150;\n    $timeout.cancel(resizeTimeout);\n    resizeTimeout = $timeout(function () {\n      ctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\n      if (!ctrl.enabled) {\n        return;\n      }\n\n      // snap back to current panel after resizing\n      snapToPanel(ctrl.currentPanel);\n    }, threshold);\n  }\n\n  function scrollStop(e) {\n    e.stopPropagation();\n\n    // if (ctrl.isMouseDown) {\n    //  return;\n    // }\n\n    if (ctrl.isSnapping) {\n      return;\n    }\n\n    var target;\n    var offset = ctrl.snapContainer.scrollTop();\n\n    if (!ctrl.enabled) {\n      // still want to activate the correct panel even if snapping is disabled\n      target = Math.max(0, Math.min(Math.round(offset / ctrl.scrollInterval), ctrl.panels.length - 1));\n      if (target !== ctrl.currentPanel) {\n        activatePanel(target);\n      }\n      return;\n    }\n\n    var scrollDifference = offset - ctrl.scrollOffset;\n    var maxOffset = ctrl.container[0].scrollHeight - ctrl.scrollInterval;\n\n    // determine target panel\n    if (scrollDifference < -ctrl.threshold && scrollDifference > -ctrl.scrollInterval) {\n      target = Math.floor(offset / ctrl.scrollInterval);\n    } else if (scrollDifference > ctrl.threshold && scrollDifference < ctrl.scrollInterval) {\n      target = Math.ceil(offset / ctrl.scrollInterval);\n    } else {\n      target = Math.round(offset / ctrl.scrollInterval);\n    }\n\n    // ensure target is within panel array bounds\n    target = Math.max(0, Math.min(target, ctrl.panels.length - 1));\n\n    if (scrollDifference === 0) {\n      // Do nothing\n    } else if (offset <= 0 || offset >= maxOffset) {\n      // only activate to prevent stuttering\n      activatePanel(target);\n      // set a scrollOffset to a sane number for next scroll\n      ctrl.scrollOffset = offset <= 0 ? 0 : maxOffset;\n    } else {\n      snapToPanel(target);\n    }\n  }\n\n  function snapToPanel(target) {\n    if (isNaN(target) || target < 0 || target >= ctrl.panels.length) {\n      return;\n    }\n\n    ctrl.isSnapping = true;\n\n    $rootScope.$broadcast('panelsnap:start', { group: $scope.name, id: target });\n    $timeout(function() { // lets the broadcast get processed before continuing\n      ctrl.panels[ctrl.currentPanel].onLeave();\n\n      var scrollTarget = ctrl.scrollInterval * target;\n      ctrl.snapContainer.scrollTo(0, scrollTarget, ctrl.speed).then(function () {\n        ctrl.scrollOffset = scrollTarget;\n        $timeout(function(){\n          ctrl.isSnapping = false;\n        },300);\n\n\n        $rootScope.$broadcast('panelsnap:finish', { group: $scope.name, id: target });\n        ctrl.panels[target].onEnter();\n\n        activatePanel(target);\n      });\n    },0);\n  }\n\n  function activatePanel(target) {\n    // if no panels, or panels have not yet loaded (within ng-repeat) return\n    if (!ctrl.panels || ctrl.panels.length < 1) {\n      return;\n    }\n\n    angular.forEach(ctrl.panels, function (panel) {\n      panel.setActive(false);\n    });\n    ctrl.panels[target].setActive(true);\n    ctrl.currentPanel = target;\n\n    // TODO: call onActivate function for target\n    $rootScope.$broadcast('panelsnap:activate', {group: $scope.name, id: target });\n    $rootScope.$emit('panelsnap:activatePanel', { group: $scope.name, id: target });\n  }\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel directive\n *\n * Creates a panel inside an ak-panel-group directive. Must be a child of an ak-panel-group element.\n *\n * @attribute name (optional) String: name of panel, will form text of nav element in any ak-panel-group-menu's assocaited with the containing group\n * @attribute onEnter (optional) Function: function to be called when panel is snapped into\n * @attribute onLeave (optional) Function: function to be called when panel is snapped out of\n */\nangular\n  .module('panel-snap')\n  .directive('akPanel', akPanel);\n\n/* @ngInject */\nfunction akPanel () {\n  return {\n    restrict: 'EA',\n    require: '^akPanelGroup',\n    replace: true,\n    transclude: true,\n    scope: {\n      name: '@',\n      onEnter: '&',\n      onLeave: '&'\n    },\n    template: '<div class=\"ak-panel\" ng-class=\"{active: active}\" ng-transclude></div>',\n    link: function (scope, element, attrs, ctrl) {\n\n      // add to parent ak-panel-group\n      ctrl.addPanel(scope);\n\n      // default panel styles\n      element.css({\n        'width': '100%',\n        'height': '100%',\n        'position': 'relative'\n      });\n\n      // attach enable/disable scroll methods to scope - need be accessed by $parent due to transclude scope\n      scope.enableSnap = ctrl.enableSnap;\n      scope.disableSnap = ctrl.disableSnap;\n      scope.toggleSnap = ctrl.toggleSnap;\n      scope.snapTo = ctrl.snapTo;\n\n      // active flag and getter function, to set class .active on panel\n      scope.active = false;\n      scope.setActive = function (active) {\n        scope.active = active;\n      };\n    }\n  };\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * Scroll methods - removes the need for external jQuery or GreenSock libraries\n *\n * Adapted from durated's Angular Scroll module\n * https://github.com/durated/angular-scroll\n */\nangular\n  .module('panel-snap')\n  .value('scrollEasing', scrollEasing)\n  .run(runFn)\n  .factory('polyfill', polyfill)\n  .factory('requestAnimation', requestAnimation)\n  .factory('cancelAnimation', cancelAnimation);\n\nfunction scrollEasing (x) {\n  if(x < 0.5) {\n    return Math.pow(x*2, 2)/2;\n  }\n  return 1-Math.pow((1-x)*2, 2)/2;\n}\n\n/* @ngInject */\nfunction runFn ($window, $q, cancelAnimation, requestAnimation, scrollEasing) {\n  var proto = angular.element.prototype;\n\n  var isDocument = function(el) {\n    return (typeof HTMLDocument !== 'undefined' && el instanceof HTMLDocument) || (el.nodeType && el.nodeType === el.DOCUMENT_NODE);\n  };\n\n  var isElement = function(el) {\n    return (typeof HTMLElement !== 'undefined' && el instanceof HTMLElement) || (el.nodeType && el.nodeType === el.ELEMENT_NODE);\n  };\n\n  var unwrap = function(el) {\n    return isElement(el) || isDocument(el) ? el : el[0];\n  };\n\n  proto.scrollTo = function(left, top, duration) {\n    var aliasFn;\n    if(angular.isElement(left)) {\n      aliasFn = this.scrollToElement;\n    } else if(duration) {\n      aliasFn = this.scrollToAnimated;\n    }\n    if(aliasFn) {\n      return aliasFn.apply(this, arguments);\n    }\n    var el = unwrap(this);\n    if(isDocument(el)) {\n      return $window.scrollTo(left, top);\n    }\n    el.scrollLeft = left;\n    el.scrollTop = top;\n  };\n\n  proto.scrollToAnimated = function(left, top, duration, easing) {\n    var scrollAnimation, deferred;\n    if(duration && !easing) {\n      easing = scrollEasing;\n    }\n    var startLeft = this.scrollLeft(),\n      startTop = this.scrollTop(),\n      deltaLeft = Math.round(left - startLeft),\n      deltaTop = Math.round(top - startTop);\n\n    var startTime = null;\n    var el = this;\n\n    var cancelOnEvents = 'scroll mousedown mousewheel touchmove keydown';\n    var cancelScrollAnimation = function($event) {\n      if (!$event || $event.which > 0) {\n        el.unbind(cancelOnEvents, cancelScrollAnimation);\n        cancelAnimation(scrollAnimation);\n        deferred.reject();\n        scrollAnimation = null;\n      }\n    };\n\n    if(scrollAnimation) {\n      cancelScrollAnimation();\n    }\n    deferred = $q.defer();\n\n    if(!deltaLeft && !deltaTop) {\n      deferred.resolve();\n      return deferred.promise;\n    }\n\n    var animationStep = function(timestamp) {\n      if (startTime === null) {\n        startTime = timestamp;\n      }\n\n      var progress = timestamp - startTime;\n      var percent = (progress >= duration ? 1 : easing(progress/duration));\n\n      el.scrollTo(\n        startLeft + Math.ceil(deltaLeft * percent),\n        startTop + Math.ceil(deltaTop * percent)\n      );\n      if(percent < 1) {\n        scrollAnimation = requestAnimation(animationStep);\n      } else {\n        el.unbind(cancelOnEvents, cancelScrollAnimation);\n        scrollAnimation = null;\n        deferred.resolve();\n      }\n    };\n\n    //Fix random mobile safari bug when scrolling to top by hitting status bar\n    el.scrollTo(startLeft, startTop);\n\n    // el.bind(cancelOnEvents, cancelScrollAnimation);\n\n    scrollAnimation = requestAnimation(animationStep);\n    return deferred.promise;\n  };\n\n  proto.scrollToElement = function(target, offset, duration, easing) {\n    var el = unwrap(this);\n    var top = this.scrollTop() + unwrap(target).getBoundingClientRect().top - (offset || 0);\n    if(isElement(el)) {\n      top -= el.getBoundingClientRect().top;\n    }\n    return this.scrollTo(0, top, duration, easing);\n  };\n\n  var overloaders = {\n    scrollLeft: function(value, duration, easing) {\n      if(angular.isNumber(value)) {\n        return this.scrollTo(value, this.scrollTop(), duration, easing);\n      }\n      var el = unwrap(this);\n      if(isDocument(el)) {\n        return $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft;\n      }\n      return el.scrollLeft;\n    },\n    scrollTop: function(value, duration, easing) {\n      if(angular.isNumber(value)) {\n        return this.scrollTo(this.scrollTop(), value, duration, easing);\n      }\n      var el = unwrap(this);\n      if(isDocument(el)) {\n        return $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop;\n      }\n      return el.scrollTop;\n    }\n  };\n\n  //Add duration and easing functionality to existing jQuery getter/setters\n  var overloadScrollPos = function(superFn, overloadFn) {\n    return function(value, duration) {\n      if(duration) {\n        return overloadFn.apply(this, arguments);\n      }\n      return superFn.apply(this, arguments);\n    };\n  };\n\n  for(var methodName in overloaders) {\n    proto[methodName] = (proto[methodName] ? overloadScrollPos(proto[methodName], overloaders[methodName]) : overloaders[methodName]);\n  }\n}\n\n/* @ngInject */\nfunction polyfill ($window) {\n  var vendors = ['webkit', 'moz', 'o', 'ms'];\n\n  return function(fnName, fallback) {\n    if($window[fnName]) {\n      return $window[fnName];\n    }\n    var suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1);\n    for(var key, i = 0; i < vendors.length; i++) {\n      key = vendors[i]+suffix;\n      if($window[key]) {\n        return $window[key];\n      }\n    }\n    return fallback;\n  };\n}\n\n/* @ngInject */\nfunction requestAnimation (polyfill, $timeout) {\n  var lastTime = 0;\n  var fallback = function(callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = $timeout(function() {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n\n  return polyfill('requestAnimationFrame', fallback);\n}\n\n/* @ngInject */\nfunction cancelAnimation (polyfill, $timeout) {\n  var fallback = function(promise) {\n    $timeout.cancel(promise);\n  };\n\n  return polyfill('cancelAnimationFrame', fallback);\n}\n\n\n})();\n"],"sourceRoot":"/source/"}