{"version":3,"sources":["module.js","menu.js","angular-panel-snap.min.js","panel-group.js","panel.js","scroll.js"],"names":["angular","module","akPanelGroupMenu","$rootScope","$log","restrict","template","scope","for","link","isDefined","panels","$on","event","data","group","stopPropagation","panel","id","name","active","push","forEach","select","$emit","error","directive","$inject","akPanelGroup","replace","controller","speed","threshold","fullWindow","keyboard","prevKey","nextKey","init","panelGroupController","$scope","$element","$attrs","$window","$timeout","$document","bind","ctrl","eventContainer","on","scrollFn","element","resize","keydown","e","enabled","isSnapping","which","preventDefault","snapToPanel","currentPanel","cancel","scrollTimeout","scrollStop","resizeTimeout","scrollInterval","isNaN","container","innerHeight","clientHeight","target","offset","snapContainer","scrollTop","Math","max","min","round","length","activatePanel","scrollDifference","scrollOffset","maxOffset","scrollHeight","floor","ceil","$broadcast","onLeave","scrollTarget","scrollTo","then","onEnter","setActive","this","addPanel","panelScope","panelName","enableSnap","disableSnap","toggleSnap","snapTo","documentElement","akPanel","require","transclude","attrs","css","width","height","position","overflow","scrollEasing","x","pow","runFn","$q","cancelAnimation","requestAnimation","proto","prototype","isDocument","el","HTMLDocument","nodeType","DOCUMENT_NODE","isElement","HTMLElement","ELEMENT_NODE","unwrap","left","top","duration","aliasFn","scrollToElement","scrollToAnimated","apply","arguments","scrollLeft","easing","scrollAnimation","deferred","startLeft","startTop","deltaLeft","deltaTop","startTime","cancelOnEvents","cancelScrollAnimation","$event","unbind","reject","defer","resolve","promise","animationStep","timestamp","progress","percent","getBoundingClientRect","overloaders","value","isNumber","scrollX","document","body","scrollY","overloadScrollPos","superFn","overloadFn","methodName","polyfill","vendors","fnName","fallback","key","suffix","substr","toUpperCase","i","lastTime","callback","currTime","Date","getTime","timeToCall","run","factory"],"mappings":"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","file":"angular-panel-snap.min.js","sourcesContent":["(function() {\n'use strict';\n\n/*\n * angular-panel-snap main module definition\n */\nangular.module('akreitals.panel-snap', []);\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel-group-menu directive\n *\n * Creates a menu for the referenced ak-panel-group container\n *\n * @attribute for (required) String: name attribute of the ak-panel-group the menu is to reference\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanelGroupMenu', akPanelGroupMenu);\n\n/* @ngInject */\nfunction akPanelGroupMenu ($rootScope, $log) {\n\treturn {\n\t\trestrict: 'EA',\n\t\ttemplate: '<ul class=\"ak-menu\"><li ng-repeat=\"panel in panels\" ng-class=\"{active: panel.active}\" ng-click=\"select(panel.id)\"><a href>{{panel.name}}</a></li></ul>',\n\t\tscope: {\n\t\t\tfor: '@'\n\t\t},\n\t\tlink: function (scope) {\n\t\t\tif (!angular.isDefined(scope.for)) {\n\t\t\t\t$log.error(\"PanelGroupMenu: no 'for' attribute provided\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tscope.panels = [];\n\n\t\t\t/*\n\t\t\t * listen for addedPanel event, if group name matches then add\n\t\t\t * it to the menu\n\t\t\t */\n\t\t\t$rootScope.$on('panelsnap:addedPanel', function (event, data) {\n\t\t\t\tif (scope.for === data.group) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tvar panel = {\n\t\t\t\t\t\tid: data.id,\n\t\t\t\t\t\tname: data.name,\n\t\t\t\t\t\tactive: false\n\t\t\t\t\t};\n\t\t\t\t\tscope.panels.push(panel);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t * listen for activatePanel event, if group name matches then set\n\t\t\t * active flag target menu element\n\t\t\t */\n\t\t\t$rootScope.$on('panelsnap:activatePanel', function (event, data) {\n\t\t\t\tif (scope.for === data.group) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tangular.forEach(scope.panels, function (panel) {\n\t\t\t\t\t\tpanel.active = false;\n\t\t\t\t\t});\n\t\t\t\t\tscope.panels[data.id].active = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t * emit event to tell ak-panel-group directive to select the target panel\n\t\t\t */\n\t\t\tscope.select = function (id) {\n\t\t\t\t$rootScope.$emit('panelsnap:selectPanel', {group: scope.for, id: id});\n\t\t\t};\n\t\t}\n\t};\n}\n\n})();\n","(function() {\n'use strict';\n\n/*\n * angular-panel-snap main module definition\n */\nangular.module('akreitals.panel-snap', []);\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel-group-menu directive\n *\n * Creates a menu for the referenced ak-panel-group container\n *\n * @attribute for (required) String: name attribute of the ak-panel-group the menu is to reference\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanelGroupMenu', akPanelGroupMenu);\n\n/* @ngInject */\nfunction akPanelGroupMenu ($rootScope, $log) {\n\treturn {\n\t\trestrict: 'EA',\n\t\ttemplate: '<ul class=\"ak-menu\"><li ng-repeat=\"panel in panels\" ng-class=\"{active: panel.active}\" ng-click=\"select(panel.id)\"><a href>{{panel.name}}</a></li></ul>',\n\t\tscope: {\n\t\t\tfor: '@'\n\t\t},\n\t\tlink: function (scope) {\n\t\t\tif (!angular.isDefined(scope.for)) {\n\t\t\t\t$log.error(\"PanelGroupMenu: no 'for' attribute provided\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tscope.panels = [];\n\n\t\t\t/*\n\t\t\t * listen for addedPanel event, if group name matches then add\n\t\t\t * it to the menu\n\t\t\t */\n\t\t\t$rootScope.$on('panelsnap:addedPanel', function (event, data) {\n\t\t\t\tif (scope.for === data.group) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tvar panel = {\n\t\t\t\t\t\tid: data.id,\n\t\t\t\t\t\tname: data.name,\n\t\t\t\t\t\tactive: false\n\t\t\t\t\t};\n\t\t\t\t\tscope.panels.push(panel);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t * listen for activatePanel event, if group name matches then set\n\t\t\t * active flag target menu element\n\t\t\t */\n\t\t\t$rootScope.$on('panelsnap:activatePanel', function (event, data) {\n\t\t\t\tif (scope.for === data.group) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tangular.forEach(scope.panels, function (panel) {\n\t\t\t\t\t\tpanel.active = false;\n\t\t\t\t\t});\n\t\t\t\t\tscope.panels[data.id].active = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t * emit event to tell ak-panel-group directive to select the target panel\n\t\t\t */\n\t\t\tscope.select = function (id) {\n\t\t\t\t$rootScope.$emit('panelsnap:selectPanel', {group: scope.for, id: id});\n\t\t\t};\n\t\t}\n\t};\n}\nakPanelGroupMenu.$inject = [\"$rootScope\", \"$log\"];\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel-group directive\n *\n * Container for set of 'ak-panel' directives that maintains the panels state and all interactions with the group\n *\n * @attribute name (optional) String: name of the group, to be referenced in ak-panel-group-menu's 'for' attribute\n * @attribute speed (optional) Number: duration in milliseconds to snap to the desired panel, defaults to 400ms\n * @attribute threshold (optional) Number: amount of pixels required to scroll before snapping to the next panel, defults to 50px\n * @attribute fullWindow (optional) Boolean: true if the panels are to fill the full browser window\n * @attribute keyboard (optional) Boolean: true if key presses can be used to navigate panels\n * @attribute prevKey (optional) Number: keyCode of key to navigate to previous panel, defaults to 38 (up arrow)\n * @attribute nextKey (optional) Number: keyCode of key to navigate to next panel, defaults to 40 (down arrow)\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanelGroup', akPanelGroup)\n\t.controller('PanelGroupController', panelGroupController);\n\n/* @ngInject */\nfunction akPanelGroup () {\n\treturn {\n\t\trestrict: 'EA',\n\t\treplace: true,\n\t\tcontroller: 'PanelGroupController',\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\tspeed: '=',\n\t\t\tthreshold: '=',\n\t\t\tfullWindow: '=',\n\t\t\tkeyboard: '=',\n\t\t\tprevKey: '=',\n\t\t\tnextKey: '='\n\t\t},\n\t\tlink: function (scope) {\n\t\t\t// Call init after child panels have registered with the controller\n\t\t\tscope.init();\n\t\t}\n\t};\n}\n\n/* @ngInject */\nfunction panelGroupController ($scope, $element, $attrs, $window, $timeout, $document, $rootScope) {\n\tvar ctrl = this;\n\n\tvar resizeTimeout;\n\tvar scrollTimeout;\n\n\tctrl.panels = [];\n\n\tctrl.currentPanel = 0;\n\tctrl.scrollInterval = 0;\n\tctrl.scrollOffset = 0;\n\tctrl.isSnapping = false;\n\tctrl.enabled = true;\n\n\tctrl.speed = 400;\t\t// default snap animation duration in milliseconds\n\tctrl.threshold = 50;\t// default pixel threshold for snap to occur in pixels\n\tctrl.prevKey = 38;\t\t// default prevKey key code - up arrow\n\tctrl.nextKey = 40;\t\t// default nextKey key code - down arrow\n\n\t/*\n\t * add a panels scope to the panels array\n\t * - attached to `this` so it can be called from child panel directives\n\t */\n\tctrl.addPanel = function (panelScope) {\n\t\tvar panelName = angular.isDefined(panelScope.name) ? panelScope.name : 'Panel ' + (ctrl.panels.length + 1);\n\t\tctrl.panels.push(panelScope);\n\t\tif (angular.isDefined($scope.name)) {\n\t\t\t$rootScope.$emit('panelsnap:addedPanel', { group: $scope.name, name: panelName, id: ctrl.panels.length-1 });\n\t\t}\n\t};\n\n\t/*\n\t * enable snapping\n\t */\n\tctrl.enableSnap = function () {\n\t\t// TODO: should this snap to closest panel when enabled?\n\t\tctrl.enabled = true;\n\t};\n\n\t/*\n\t * disable snapping\n\t */\n\tctrl.disableSnap = function () {\n\t\tctrl.enabled = false;\n\t};\n\n\t/*\n\t * toggle snapping\n\t */\n\tctrl.toggleSnap = function () {\n\t\tctrl.enabled = !ctrl.enabled;\n\t};\n\n\t/*\n\t * toggle snapping\n\t */\n\tctrl.snapTo = function (id) {\n  \tsnapToPanel(id);\n\t};\n\n\t/*\n\t * initialise the controller state\n\t * - called from the directive link function. This ensures it is called after any child panels\n\t *  link function has called addPanel and therefore the panels array is filled and valid.\n\t */\n\t$scope.init = function () {\n\t\tctrl.container = $element;\n\t\tctrl.eventContainer = ctrl.container;\n\t\tctrl.snapContainer = ctrl.container;\n\n\t\t// if full window, bind and snap using document instead of element\n\t\tif ($scope.fullWindow) {\n\t\t\tctrl.container = angular.element($document[0].documentElement);\n\t\t\tctrl.eventContainer = ctrl.snapContainer = $document;\n\t\t}\n\n\t\t// set options / variables\n\t\tctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\t\tctrl.speed = angular.isDefined($scope.speed) ? $scope.speed : ctrl.speed;\n\t\tctrl.threshold = angular.isDefined($scope.threshold) ? $scope.threshold : ctrl.threshold;\n\t\tctrl.prevKey = angular.isDefined($scope.prevKey) ? $scope.prevKey : ctrl.prevKey;\n\t\tctrl.nextKey = angular.isDefined($scope.nextKey) ? $scope.nextKey : ctrl.nextKey;\n\n\t\tbind();\n\t\tactivatePanel(ctrl.currentPanel);\n\t};\n\n\t/*\n\t * listen for selectPanel event, if group name matches then snap\n\t * to the target panel\n\t */\n\t$rootScope.$on('panelsnap:selectPanel', function (event, data) {\n\t\tif ($scope.name === data.group) {\n\t\t\tevent.stopPropagation();\n\t\t\tsnapToPanel(data.id);\n\t\t}\n\t});\n\n\tfunction bind() {\n\t\t// bind scrolling events\n\t\tctrl.eventContainer.on('mousewheel scroll touchmove', scrollFn);\n\n\t\t// bind resize event\n\t\tangular.element($window).on('resize', resize);\n\n\t\t// bind keyboard events\n\t\tif ($scope.keyboard) {\n\t\t\tangular.element($window).on('keydown', keydown);\n\t\t}\n\t}\n\n\tfunction keydown(e) {\n\t\tif (!ctrl.enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// prevent any keypress events while snapping\n\t\tif (ctrl.isSnapping) {\n\t\t\tif (e.which === ctrl.prevKey || e.which === ctrl.nextKey) {\n\t\t\t\te.preventDefault();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (e.which) {\n\t\t\tcase ctrl.prevKey:\n\t\t\t\te.preventDefault();\n\t\t\t\tsnapToPanel(ctrl.currentPanel - 1);\n\t\t\t\tbreak;\n\t\t\tcase ctrl.nextKey:\n\t\t\t\te.preventDefault();\n\t\t\t\tsnapToPanel(ctrl.currentPanel + 1);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfunction scrollFn(e) {\n\t\tvar threshold = 50;\n\t\t$timeout.cancel(scrollTimeout);\n\t\tscrollTimeout = $timeout(function () {\n\t\t\tscrollStop(e);\n\t\t}, threshold);\n\t}\n\n\tfunction resize() {\n\t\tvar threshold = 150;\n\t\t$timeout.cancel(resizeTimeout);\n\t\tresizeTimeout = $timeout(function () {\n\t\t\tctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\n\t\t\tif (!ctrl.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// snap back to current panel after resizing\n\t\t\tsnapToPanel(ctrl.currentPanel);\n\t\t}, threshold);\n\t}\n\n\tfunction scrollStop(e) {\n\t\te.stopPropagation();\n\n\t\t// if (ctrl.isMouseDown) {\n\t\t// \treturn;\n\t\t// }\n\n\t\tif (ctrl.isSnapping) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar target;\n\t\tvar offset = ctrl.snapContainer.scrollTop();\n\n\t\tif (!ctrl.enabled) {\n\t\t\t// still want to activate the correct panel even if snapping is disabled\n\t\t\ttarget = Math.max(0, Math.min(Math.round(offset / ctrl.scrollInterval), ctrl.panels.length - 1));\n\t\t\tif (target !== ctrl.currentPanel) {\n\t\t\t\tactivatePanel(target);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar scrollDifference = offset - ctrl.scrollOffset;\n\t\tvar maxOffset = ctrl.container[0].scrollHeight - ctrl.scrollInterval;\n\n\t\t// determine target panel\n\t\tif (scrollDifference < -ctrl.threshold && scrollDifference > -ctrl.scrollInterval) {\n\t\t\ttarget = Math.floor(offset / ctrl.scrollInterval);\n\t\t} else if (scrollDifference > ctrl.threshold && scrollDifference < ctrl.scrollInterval) {\n\t\t\ttarget = Math.ceil(offset / ctrl.scrollInterval);\n\t\t} else {\n\t\t\ttarget = Math.round(offset / ctrl.scrollInterval);\n\t\t}\n\n\t\t// ensure target is within panel array bounds\n\t\ttarget = Math.max(0, Math.min(target, ctrl.panels.length - 1));\n\n\t\tif (scrollDifference === 0) {\n\t\t\t// Do nothing\n\t\t} else if (offset <= 0 || offset >= maxOffset) {\n\t\t\t// only activate to prevent stuttering\n\t\t\tactivatePanel(target);\n\t\t\t// set a scrollOffset to a sane number for next scroll\n\t\t\tctrl.scrollOffset = offset <= 0 ? 0 : maxOffset;\n\t\t} else {\n\t\t\tsnapToPanel(target);\n\t\t}\n\t}\n\n\tfunction snapToPanel(target) {\n\t\tif (isNaN(target) || target < 0 || target >= ctrl.panels.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tctrl.isSnapping = true;\n\n\t\t$rootScope.$broadcast('panelsnap:start', { group: $scope.name });\n\t\tctrl.panels[ctrl.currentPanel].onLeave();\n\n\t\tvar scrollTarget = ctrl.scrollInterval * target;\n\t\tctrl.snapContainer.scrollTo(0, scrollTarget, ctrl.speed).then(function () {\n\t\t\tctrl.scrollOffset = scrollTarget;\n\t\t\tctrl.isSnapping = false;\n\n\t\t\t$rootScope.$broadcast('panelsnap:finish', { group: $scope.name });\n\t\t\tctrl.panels[target].onEnter();\n\n\t\t\tactivatePanel(target);\n\t\t});\n\t}\n\n\tfunction activatePanel(target) {\n\t\t// if no panels, or panels have not yet loaded (within ng-repeat) return\n\t\tif (!ctrl.panels || ctrl.panels.length < 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tangular.forEach(ctrl.panels, function (panel) {\n\t\t\tpanel.setActive(false);\n\t\t});\n\t\tctrl.panels[target].setActive(true);\n\t\tctrl.currentPanel = target;\n\n\t\t// TODO: call onActivate function for target\n\t\t$rootScope.$broadcast('panelsnap:activate', {group: $scope.name });\n\t\t$rootScope.$emit('panelsnap:activatePanel', { group: $scope.name, id: target });\n\t}\n}\npanelGroupController.$inject = [\"$scope\", \"$element\", \"$attrs\", \"$window\", \"$timeout\", \"$document\", \"$rootScope\"];\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel directive\n *\n * Creates a panel inside an ak-panel-group directive. Must be a child of an ak-panel-group element.\n *\n * @attribute name (optional) String: name of panel, will form text of nav element in any ak-panel-group-menu's assocaited with the containing group\n * @attribute onEnter (optional) Function: function to be called when panel is snapped into\n * @attribute onLeave (optional) Function: function to be called when panel is snapped out of\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanel', akPanel);\n\n/* @ngInject */\nfunction akPanel () {\n\treturn {\n\t\trestrict: 'EA',\n\t\trequire: '^akPanelGroup',\n\t\treplace: true,\n\t\ttransclude: true,\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\tonEnter: '&',\n\t\t\tonLeave: '&'\n\t\t},\n\t\ttemplate: '<div class=\"ak-panel\" ng-class=\"{active: active}\" ng-transclude></div>',\n\t\tlink: function (scope, element, attrs, ctrl) {\n\n\t\t\t// add to parent ak-panel-group\n\t\t\tctrl.addPanel(scope);\n\n\t\t\t// default panel styles\n\t\t\telement.css({\n\t\t\t\t'width': '100%',\n\t\t\t\t'height': '100%',\n\t\t\t\t'position': 'relative',\n\t\t\t\t'overflow': 'hidden'\n\t\t\t});\n\n\t\t\t// attach enable/disable scroll methods to scope - need be accessed by $parent due to transclude scope\n\t\t\tscope.enableSnap = ctrl.enableSnap;\n\t\t\tscope.disableSnap = ctrl.disableSnap;\n\t\t\tscope.toggleSnap = ctrl.toggleSnap;\n\t\t\tscope.snapTo = ctrl.snapTo;\n\n\t\t\t// active flag and getter function, to set class .active on panel\n\t\t\tscope.active = false;\n\t\t\tscope.setActive = function (active) {\n\t\t\t\tscope.active = active;\n\t\t\t};\n\t\t}\n\t};\n}\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * Scroll methods - removes the need for external jQuery or GreenSock libraries\n *\n * Adapted from durated's Angular Scroll module\n * https://github.com/durated/angular-scroll\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.value('scrollEasing', scrollEasing)\n\t.run(runFn)\n\t.factory('polyfill', polyfill)\n\t.factory('requestAnimation', requestAnimation)\n\t.factory('cancelAnimation', cancelAnimation);\n\nfunction scrollEasing (x) {\n\tif(x < 0.5) {\n\t\treturn Math.pow(x*2, 2)/2;\n\t}\n\treturn 1-Math.pow((1-x)*2, 2)/2;\n}\n\n/* @ngInject */\nfunction runFn ($window, $q, cancelAnimation, requestAnimation, scrollEasing) {\n\tvar proto = angular.element.prototype;\n\n\tvar isDocument = function(el) {\n\t\treturn (typeof HTMLDocument !== 'undefined' && el instanceof HTMLDocument) || (el.nodeType && el.nodeType === el.DOCUMENT_NODE);\n\t};\n\n\tvar isElement = function(el) {\n\t\treturn (typeof HTMLElement !== 'undefined' && el instanceof HTMLElement) || (el.nodeType && el.nodeType === el.ELEMENT_NODE);\n\t};\n\n\tvar unwrap = function(el) {\n\t\treturn isElement(el) || isDocument(el) ? el : el[0];\n\t};\n\n\tproto.scrollTo = function(left, top, duration) {\n\t\tvar aliasFn;\n\t\tif(angular.isElement(left)) {\n\t\t\taliasFn = this.scrollToElement;\n\t\t} else if(duration) {\n\t\t\taliasFn = this.scrollToAnimated;\n\t\t}\n\t\tif(aliasFn) {\n\t\t\treturn aliasFn.apply(this, arguments);\n\t\t}\n\t\tvar el = unwrap(this);\n\t\tif(isDocument(el)) {\n\t\t\treturn $window.scrollTo(left, top);\n\t\t}\n\t\tel.scrollLeft = left;\n\t\tel.scrollTop = top;\n\t};\n\n\tproto.scrollToAnimated = function(left, top, duration, easing) {\n\t\tvar scrollAnimation, deferred;\n\t\tif(duration && !easing) {\n\t\t\teasing = scrollEasing;\n\t\t}\n\t\tvar startLeft = this.scrollLeft(),\n\t\t\tstartTop = this.scrollTop(),\n\t\t\tdeltaLeft = Math.round(left - startLeft),\n\t\t\tdeltaTop = Math.round(top - startTop);\n\n\t\tvar startTime = null;\n\t\tvar el = this;\n\n\t\tvar cancelOnEvents = 'scroll mousedown mousewheel touchmove keydown';\n\t\tvar cancelScrollAnimation = function($event) {\n\t\t\tif (!$event || $event.which > 0) {\n\t\t\t\tel.unbind(cancelOnEvents, cancelScrollAnimation);\n\t\t\t\tcancelAnimation(scrollAnimation);\n\t\t\t\tdeferred.reject();\n\t\t\t\tscrollAnimation = null;\n\t\t\t}\n\t\t};\n\n\t\tif(scrollAnimation) {\n\t\t\tcancelScrollAnimation();\n\t\t}\n\t\tdeferred = $q.defer();\n\n\t\tif(!deltaLeft && !deltaTop) {\n\t\t\tdeferred.resolve();\n\t\t\treturn deferred.promise;\n\t\t}\n\n\t\tvar animationStep = function(timestamp) {\n\t\t\tif (startTime === null) {\n\t\t\t\tstartTime = timestamp;\n\t\t\t}\n\n\t\t\tvar progress = timestamp - startTime;\n\t\t\tvar percent = (progress >= duration ? 1 : easing(progress/duration));\n\n\t\t\tel.scrollTo(\n\t\t\t\tstartLeft + Math.ceil(deltaLeft * percent),\n\t\t\t\tstartTop + Math.ceil(deltaTop * percent)\n\t\t\t);\n\t\t\tif(percent < 1) {\n\t\t\t\tscrollAnimation = requestAnimation(animationStep);\n\t\t\t} else {\n\t\t\t\tel.unbind(cancelOnEvents, cancelScrollAnimation);\n\t\t\t\tscrollAnimation = null;\n\t\t\t\tdeferred.resolve();\n\t\t\t}\n\t\t};\n\n\t\t//Fix random mobile safari bug when scrolling to top by hitting status bar\n\t\tel.scrollTo(startLeft, startTop);\n\n\t\t// el.bind(cancelOnEvents, cancelScrollAnimation);\n\n\t\tscrollAnimation = requestAnimation(animationStep);\n\t\treturn deferred.promise;\n\t};\n\n\tproto.scrollToElement = function(target, offset, duration, easing) {\n\t\tvar el = unwrap(this);\n\t\tvar top = this.scrollTop() + unwrap(target).getBoundingClientRect().top - (offset || 0);\n\t\tif(isElement(el)) {\n\t\t\ttop -= el.getBoundingClientRect().top;\n\t\t}\n\t\treturn this.scrollTo(0, top, duration, easing);\n\t};\n\n\tvar overloaders = {\n\t\tscrollLeft: function(value, duration, easing) {\n\t\t\tif(angular.isNumber(value)) {\n\t\t\t\treturn this.scrollTo(value, this.scrollTop(), duration, easing);\n\t\t\t}\n\t\t\tvar el = unwrap(this);\n\t\t\tif(isDocument(el)) {\n\t\t\t\treturn $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft;\n\t\t\t}\n\t\t\treturn el.scrollLeft;\n\t\t},\n\t\tscrollTop: function(value, duration, easing) {\n\t\t\tif(angular.isNumber(value)) {\n\t\t\t\treturn this.scrollTo(this.scrollTop(), value, duration, easing);\n\t\t\t}\n\t\t\tvar el = unwrap(this);\n\t\t\tif(isDocument(el)) {\n\t\t\t\treturn $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\t}\n\t\t\treturn el.scrollTop;\n\t\t}\n\t};\n\n\t//Add duration and easing functionality to existing jQuery getter/setters\n\tvar overloadScrollPos = function(superFn, overloadFn) {\n\t\treturn function(value, duration) {\n\t\t\tif(duration) {\n\t\t\t\treturn overloadFn.apply(this, arguments);\n\t\t\t}\n\t\t\treturn superFn.apply(this, arguments);\n\t\t};\n\t};\n\n\tfor(var methodName in overloaders) {\n\t\tproto[methodName] = (proto[methodName] ? overloadScrollPos(proto[methodName], overloaders[methodName]) : overloaders[methodName]);\n\t}\n}\nrunFn.$inject = [\"$window\", \"$q\", \"cancelAnimation\", \"requestAnimation\", \"scrollEasing\"];\n\n/* @ngInject */\nfunction polyfill ($window) {\n\tvar vendors = ['webkit', 'moz', 'o', 'ms'];\n\n\treturn function(fnName, fallback) {\n\t\tif($window[fnName]) {\n\t\t\treturn $window[fnName];\n\t\t}\n\t\tvar suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1);\n\t\tfor(var key, i = 0; i < vendors.length; i++) {\n\t\t\tkey = vendors[i]+suffix;\n\t\t\tif($window[key]) {\n\t\t\t\treturn $window[key];\n\t\t\t}\n\t\t}\n\t\treturn fallback;\n\t};\n}\npolyfill.$inject = [\"$window\"];\n\n/* @ngInject */\nfunction requestAnimation (polyfill, $timeout) {\n\tvar lastTime = 0;\n\tvar fallback = function(callback) {\n\t\tvar currTime = new Date().getTime();\n\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\tvar id = $timeout(function() {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\t\tlastTime = currTime + timeToCall;\n\t\treturn id;\n\t};\n\n\treturn polyfill('requestAnimationFrame', fallback);\n}\nrequestAnimation.$inject = [\"polyfill\", \"$timeout\"];\n\n/* @ngInject */\nfunction cancelAnimation (polyfill, $timeout) {\n\tvar fallback = function(promise) {\n\t\t$timeout.cancel(promise);\n\t};\n\n\treturn polyfill('cancelAnimationFrame', fallback);\n}\ncancelAnimation.$inject = [\"polyfill\", \"$timeout\"];\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel-group directive\n *\n * Container for set of 'ak-panel' directives that maintains the panels state and all interactions with the group\n *\n * @attribute name (optional) String: name of the group, to be referenced in ak-panel-group-menu's 'for' attribute\n * @attribute speed (optional) Number: duration in milliseconds to snap to the desired panel, defaults to 400ms\n * @attribute threshold (optional) Number: amount of pixels required to scroll before snapping to the next panel, defults to 50px\n * @attribute fullWindow (optional) Boolean: true if the panels are to fill the full browser window\n * @attribute keyboard (optional) Boolean: true if key presses can be used to navigate panels\n * @attribute prevKey (optional) Number: keyCode of key to navigate to previous panel, defaults to 38 (up arrow)\n * @attribute nextKey (optional) Number: keyCode of key to navigate to next panel, defaults to 40 (down arrow)\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanelGroup', akPanelGroup)\n\t.controller('PanelGroupController', panelGroupController);\n\n/* @ngInject */\nfunction akPanelGroup () {\n\treturn {\n\t\trestrict: 'EA',\n\t\treplace: true,\n\t\tcontroller: 'PanelGroupController',\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\tspeed: '=',\n\t\t\tthreshold: '=',\n\t\t\tfullWindow: '=',\n\t\t\tkeyboard: '=',\n\t\t\tprevKey: '=',\n\t\t\tnextKey: '='\n\t\t},\n\t\tlink: function (scope) {\n\t\t\t// Call init after child panels have registered with the controller\n\t\t\tscope.init();\n\t\t}\n\t};\n}\n\n/* @ngInject */\nfunction panelGroupController ($scope, $element, $attrs, $window, $timeout, $document, $rootScope) {\n\tvar ctrl = this;\n\n\tvar resizeTimeout;\n\tvar scrollTimeout;\n\n\tctrl.panels = [];\n\n\tctrl.currentPanel = 0;\n\tctrl.scrollInterval = 0;\n\tctrl.scrollOffset = 0;\n\tctrl.isSnapping = false;\n\tctrl.enabled = true;\n\n\tctrl.speed = 400;\t\t// default snap animation duration in milliseconds\n\tctrl.threshold = 50;\t// default pixel threshold for snap to occur in pixels\n\tctrl.prevKey = 38;\t\t// default prevKey key code - up arrow\n\tctrl.nextKey = 40;\t\t// default nextKey key code - down arrow\n\n\t/*\n\t * add a panels scope to the panels array\n\t * - attached to `this` so it can be called from child panel directives\n\t */\n\tctrl.addPanel = function (panelScope) {\n\t\tvar panelName = angular.isDefined(panelScope.name) ? panelScope.name : 'Panel ' + (ctrl.panels.length + 1);\n\t\tctrl.panels.push(panelScope);\n\t\tif (angular.isDefined($scope.name)) {\n\t\t\t$rootScope.$emit('panelsnap:addedPanel', { group: $scope.name, name: panelName, id: ctrl.panels.length-1 });\n\t\t}\n\t};\n\n\t/*\n\t * enable snapping\n\t */\n\tctrl.enableSnap = function () {\n\t\t// TODO: should this snap to closest panel when enabled?\n\t\tctrl.enabled = true;\n\t};\n\n\t/*\n\t * disable snapping\n\t */\n\tctrl.disableSnap = function () {\n\t\tctrl.enabled = false;\n\t};\n\n\t/*\n\t * toggle snapping\n\t */\n\tctrl.toggleSnap = function () {\n\t\tctrl.enabled = !ctrl.enabled;\n\t};\n\n\t/*\n\t * toggle snapping\n\t */\n\tctrl.snapTo = function (id) {\n  \tsnapToPanel(id);\n\t};\n\n\t/*\n\t * initialise the controller state\n\t * - called from the directive link function. This ensures it is called after any child panels\n\t *  link function has called addPanel and therefore the panels array is filled and valid.\n\t */\n\t$scope.init = function () {\n\t\tctrl.container = $element;\n\t\tctrl.eventContainer = ctrl.container;\n\t\tctrl.snapContainer = ctrl.container;\n\n\t\t// if full window, bind and snap using document instead of element\n\t\tif ($scope.fullWindow) {\n\t\t\tctrl.container = angular.element($document[0].documentElement);\n\t\t\tctrl.eventContainer = ctrl.snapContainer = $document;\n\t\t}\n\n\t\t// set options / variables\n\t\tctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\t\tctrl.speed = angular.isDefined($scope.speed) ? $scope.speed : ctrl.speed;\n\t\tctrl.threshold = angular.isDefined($scope.threshold) ? $scope.threshold : ctrl.threshold;\n\t\tctrl.prevKey = angular.isDefined($scope.prevKey) ? $scope.prevKey : ctrl.prevKey;\n\t\tctrl.nextKey = angular.isDefined($scope.nextKey) ? $scope.nextKey : ctrl.nextKey;\n\n\t\tbind();\n\t\tactivatePanel(ctrl.currentPanel);\n\t};\n\n\t/*\n\t * listen for selectPanel event, if group name matches then snap\n\t * to the target panel\n\t */\n\t$rootScope.$on('panelsnap:selectPanel', function (event, data) {\n\t\tif ($scope.name === data.group) {\n\t\t\tevent.stopPropagation();\n\t\t\tsnapToPanel(data.id);\n\t\t}\n\t});\n\n\tfunction bind() {\n\t\t// bind scrolling events\n\t\tctrl.eventContainer.on('mousewheel scroll touchmove', scrollFn);\n\n\t\t// bind resize event\n\t\tangular.element($window).on('resize', resize);\n\n\t\t// bind keyboard events\n\t\tif ($scope.keyboard) {\n\t\t\tangular.element($window).on('keydown', keydown);\n\t\t}\n\t}\n\n\tfunction keydown(e) {\n\t\tif (!ctrl.enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// prevent any keypress events while snapping\n\t\tif (ctrl.isSnapping) {\n\t\t\tif (e.which === ctrl.prevKey || e.which === ctrl.nextKey) {\n\t\t\t\te.preventDefault();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (e.which) {\n\t\t\tcase ctrl.prevKey:\n\t\t\t\te.preventDefault();\n\t\t\t\tsnapToPanel(ctrl.currentPanel - 1);\n\t\t\t\tbreak;\n\t\t\tcase ctrl.nextKey:\n\t\t\t\te.preventDefault();\n\t\t\t\tsnapToPanel(ctrl.currentPanel + 1);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfunction scrollFn(e) {\n\t\tvar threshold = 50;\n\t\t$timeout.cancel(scrollTimeout);\n\t\tscrollTimeout = $timeout(function () {\n\t\t\tscrollStop(e);\n\t\t}, threshold);\n\t}\n\n\tfunction resize() {\n\t\tvar threshold = 150;\n\t\t$timeout.cancel(resizeTimeout);\n\t\tresizeTimeout = $timeout(function () {\n\t\t\tctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\n\t\t\tif (!ctrl.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// snap back to current panel after resizing\n\t\t\tsnapToPanel(ctrl.currentPanel);\n\t\t}, threshold);\n\t}\n\n\tfunction scrollStop(e) {\n\t\te.stopPropagation();\n\n\t\t// if (ctrl.isMouseDown) {\n\t\t// \treturn;\n\t\t// }\n\n\t\tif (ctrl.isSnapping) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar target;\n\t\tvar offset = ctrl.snapContainer.scrollTop();\n\n\t\tif (!ctrl.enabled) {\n\t\t\t// still want to activate the correct panel even if snapping is disabled\n\t\t\ttarget = Math.max(0, Math.min(Math.round(offset / ctrl.scrollInterval), ctrl.panels.length - 1));\n\t\t\tif (target !== ctrl.currentPanel) {\n\t\t\t\tactivatePanel(target);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar scrollDifference = offset - ctrl.scrollOffset;\n\t\tvar maxOffset = ctrl.container[0].scrollHeight - ctrl.scrollInterval;\n\n\t\t// determine target panel\n\t\tif (scrollDifference < -ctrl.threshold && scrollDifference > -ctrl.scrollInterval) {\n\t\t\ttarget = Math.floor(offset / ctrl.scrollInterval);\n\t\t} else if (scrollDifference > ctrl.threshold && scrollDifference < ctrl.scrollInterval) {\n\t\t\ttarget = Math.ceil(offset / ctrl.scrollInterval);\n\t\t} else {\n\t\t\ttarget = Math.round(offset / ctrl.scrollInterval);\n\t\t}\n\n\t\t// ensure target is within panel array bounds\n\t\ttarget = Math.max(0, Math.min(target, ctrl.panels.length - 1));\n\n\t\tif (scrollDifference === 0) {\n\t\t\t// Do nothing\n\t\t} else if (offset <= 0 || offset >= maxOffset) {\n\t\t\t// only activate to prevent stuttering\n\t\t\tactivatePanel(target);\n\t\t\t// set a scrollOffset to a sane number for next scroll\n\t\t\tctrl.scrollOffset = offset <= 0 ? 0 : maxOffset;\n\t\t} else {\n\t\t\tsnapToPanel(target);\n\t\t}\n\t}\n\n\tfunction snapToPanel(target) {\n\t\tif (isNaN(target) || target < 0 || target >= ctrl.panels.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tctrl.isSnapping = true;\n\n\t\t$rootScope.$broadcast('panelsnap:start', { group: $scope.name });\n\t\tctrl.panels[ctrl.currentPanel].onLeave();\n\n\t\tvar scrollTarget = ctrl.scrollInterval * target;\n\t\tctrl.snapContainer.scrollTo(0, scrollTarget, ctrl.speed).then(function () {\n\t\t\tctrl.scrollOffset = scrollTarget;\n\t\t\tctrl.isSnapping = false;\n\n\t\t\t$rootScope.$broadcast('panelsnap:finish', { group: $scope.name });\n\t\t\tctrl.panels[target].onEnter();\n\n\t\t\tactivatePanel(target);\n\t\t});\n\t}\n\n\tfunction activatePanel(target) {\n\t\t// if no panels, or panels have not yet loaded (within ng-repeat) return\n\t\tif (!ctrl.panels || ctrl.panels.length < 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tangular.forEach(ctrl.panels, function (panel) {\n\t\t\tpanel.setActive(false);\n\t\t});\n\t\tctrl.panels[target].setActive(true);\n\t\tctrl.currentPanel = target;\n\n\t\t// TODO: call onActivate function for target\n\t\t$rootScope.$broadcast('panelsnap:activate', {group: $scope.name });\n\t\t$rootScope.$emit('panelsnap:activatePanel', { group: $scope.name, id: target });\n\t}\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel directive\n *\n * Creates a panel inside an ak-panel-group directive. Must be a child of an ak-panel-group element.\n *\n * @attribute name (optional) String: name of panel, will form text of nav element in any ak-panel-group-menu's assocaited with the containing group\n * @attribute onEnter (optional) Function: function to be called when panel is snapped into\n * @attribute onLeave (optional) Function: function to be called when panel is snapped out of\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanel', akPanel);\n\n/* @ngInject */\nfunction akPanel () {\n\treturn {\n\t\trestrict: 'EA',\n\t\trequire: '^akPanelGroup',\n\t\treplace: true,\n\t\ttransclude: true,\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\tonEnter: '&',\n\t\t\tonLeave: '&'\n\t\t},\n\t\ttemplate: '<div class=\"ak-panel\" ng-class=\"{active: active}\" ng-transclude></div>',\n\t\tlink: function (scope, element, attrs, ctrl) {\n\n\t\t\t// add to parent ak-panel-group\n\t\t\tctrl.addPanel(scope);\n\n\t\t\t// default panel styles\n\t\t\telement.css({\n\t\t\t\t'width': '100%',\n\t\t\t\t'height': '100%',\n\t\t\t\t'position': 'relative',\n\t\t\t\t'overflow': 'hidden'\n\t\t\t});\n\n\t\t\t// attach enable/disable scroll methods to scope - need be accessed by $parent due to transclude scope\n\t\t\tscope.enableSnap = ctrl.enableSnap;\n\t\t\tscope.disableSnap = ctrl.disableSnap;\n\t\t\tscope.toggleSnap = ctrl.toggleSnap;\n\t\t\tscope.snapTo = ctrl.snapTo;\n\n\t\t\t// active flag and getter function, to set class .active on panel\n\t\t\tscope.active = false;\n\t\t\tscope.setActive = function (active) {\n\t\t\t\tscope.active = active;\n\t\t\t};\n\t\t}\n\t};\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * Scroll methods - removes the need for external jQuery or GreenSock libraries\n *\n * Adapted from durated's Angular Scroll module\n * https://github.com/durated/angular-scroll\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.value('scrollEasing', scrollEasing)\n\t.run(runFn)\n\t.factory('polyfill', polyfill)\n\t.factory('requestAnimation', requestAnimation)\n\t.factory('cancelAnimation', cancelAnimation);\n\nfunction scrollEasing (x) {\n\tif(x < 0.5) {\n\t\treturn Math.pow(x*2, 2)/2;\n\t}\n\treturn 1-Math.pow((1-x)*2, 2)/2;\n}\n\n/* @ngInject */\nfunction runFn ($window, $q, cancelAnimation, requestAnimation, scrollEasing) {\n\tvar proto = angular.element.prototype;\n\n\tvar isDocument = function(el) {\n\t\treturn (typeof HTMLDocument !== 'undefined' && el instanceof HTMLDocument) || (el.nodeType && el.nodeType === el.DOCUMENT_NODE);\n\t};\n\n\tvar isElement = function(el) {\n\t\treturn (typeof HTMLElement !== 'undefined' && el instanceof HTMLElement) || (el.nodeType && el.nodeType === el.ELEMENT_NODE);\n\t};\n\n\tvar unwrap = function(el) {\n\t\treturn isElement(el) || isDocument(el) ? el : el[0];\n\t};\n\n\tproto.scrollTo = function(left, top, duration) {\n\t\tvar aliasFn;\n\t\tif(angular.isElement(left)) {\n\t\t\taliasFn = this.scrollToElement;\n\t\t} else if(duration) {\n\t\t\taliasFn = this.scrollToAnimated;\n\t\t}\n\t\tif(aliasFn) {\n\t\t\treturn aliasFn.apply(this, arguments);\n\t\t}\n\t\tvar el = unwrap(this);\n\t\tif(isDocument(el)) {\n\t\t\treturn $window.scrollTo(left, top);\n\t\t}\n\t\tel.scrollLeft = left;\n\t\tel.scrollTop = top;\n\t};\n\n\tproto.scrollToAnimated = function(left, top, duration, easing) {\n\t\tvar scrollAnimation, deferred;\n\t\tif(duration && !easing) {\n\t\t\teasing = scrollEasing;\n\t\t}\n\t\tvar startLeft = this.scrollLeft(),\n\t\t\tstartTop = this.scrollTop(),\n\t\t\tdeltaLeft = Math.round(left - startLeft),\n\t\t\tdeltaTop = Math.round(top - startTop);\n\n\t\tvar startTime = null;\n\t\tvar el = this;\n\n\t\tvar cancelOnEvents = 'scroll mousedown mousewheel touchmove keydown';\n\t\tvar cancelScrollAnimation = function($event) {\n\t\t\tif (!$event || $event.which > 0) {\n\t\t\t\tel.unbind(cancelOnEvents, cancelScrollAnimation);\n\t\t\t\tcancelAnimation(scrollAnimation);\n\t\t\t\tdeferred.reject();\n\t\t\t\tscrollAnimation = null;\n\t\t\t}\n\t\t};\n\n\t\tif(scrollAnimation) {\n\t\t\tcancelScrollAnimation();\n\t\t}\n\t\tdeferred = $q.defer();\n\n\t\tif(!deltaLeft && !deltaTop) {\n\t\t\tdeferred.resolve();\n\t\t\treturn deferred.promise;\n\t\t}\n\n\t\tvar animationStep = function(timestamp) {\n\t\t\tif (startTime === null) {\n\t\t\t\tstartTime = timestamp;\n\t\t\t}\n\n\t\t\tvar progress = timestamp - startTime;\n\t\t\tvar percent = (progress >= duration ? 1 : easing(progress/duration));\n\n\t\t\tel.scrollTo(\n\t\t\t\tstartLeft + Math.ceil(deltaLeft * percent),\n\t\t\t\tstartTop + Math.ceil(deltaTop * percent)\n\t\t\t);\n\t\t\tif(percent < 1) {\n\t\t\t\tscrollAnimation = requestAnimation(animationStep);\n\t\t\t} else {\n\t\t\t\tel.unbind(cancelOnEvents, cancelScrollAnimation);\n\t\t\t\tscrollAnimation = null;\n\t\t\t\tdeferred.resolve();\n\t\t\t}\n\t\t};\n\n\t\t//Fix random mobile safari bug when scrolling to top by hitting status bar\n\t\tel.scrollTo(startLeft, startTop);\n\n\t\t// el.bind(cancelOnEvents, cancelScrollAnimation);\n\n\t\tscrollAnimation = requestAnimation(animationStep);\n\t\treturn deferred.promise;\n\t};\n\n\tproto.scrollToElement = function(target, offset, duration, easing) {\n\t\tvar el = unwrap(this);\n\t\tvar top = this.scrollTop() + unwrap(target).getBoundingClientRect().top - (offset || 0);\n\t\tif(isElement(el)) {\n\t\t\ttop -= el.getBoundingClientRect().top;\n\t\t}\n\t\treturn this.scrollTo(0, top, duration, easing);\n\t};\n\n\tvar overloaders = {\n\t\tscrollLeft: function(value, duration, easing) {\n\t\t\tif(angular.isNumber(value)) {\n\t\t\t\treturn this.scrollTo(value, this.scrollTop(), duration, easing);\n\t\t\t}\n\t\t\tvar el = unwrap(this);\n\t\t\tif(isDocument(el)) {\n\t\t\t\treturn $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft;\n\t\t\t}\n\t\t\treturn el.scrollLeft;\n\t\t},\n\t\tscrollTop: function(value, duration, easing) {\n\t\t\tif(angular.isNumber(value)) {\n\t\t\t\treturn this.scrollTo(this.scrollTop(), value, duration, easing);\n\t\t\t}\n\t\t\tvar el = unwrap(this);\n\t\t\tif(isDocument(el)) {\n\t\t\t\treturn $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\t}\n\t\t\treturn el.scrollTop;\n\t\t}\n\t};\n\n\t//Add duration and easing functionality to existing jQuery getter/setters\n\tvar overloadScrollPos = function(superFn, overloadFn) {\n\t\treturn function(value, duration) {\n\t\t\tif(duration) {\n\t\t\t\treturn overloadFn.apply(this, arguments);\n\t\t\t}\n\t\t\treturn superFn.apply(this, arguments);\n\t\t};\n\t};\n\n\tfor(var methodName in overloaders) {\n\t\tproto[methodName] = (proto[methodName] ? overloadScrollPos(proto[methodName], overloaders[methodName]) : overloaders[methodName]);\n\t}\n}\n\n/* @ngInject */\nfunction polyfill ($window) {\n\tvar vendors = ['webkit', 'moz', 'o', 'ms'];\n\n\treturn function(fnName, fallback) {\n\t\tif($window[fnName]) {\n\t\t\treturn $window[fnName];\n\t\t}\n\t\tvar suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1);\n\t\tfor(var key, i = 0; i < vendors.length; i++) {\n\t\t\tkey = vendors[i]+suffix;\n\t\t\tif($window[key]) {\n\t\t\t\treturn $window[key];\n\t\t\t}\n\t\t}\n\t\treturn fallback;\n\t};\n}\n\n/* @ngInject */\nfunction requestAnimation (polyfill, $timeout) {\n\tvar lastTime = 0;\n\tvar fallback = function(callback) {\n\t\tvar currTime = new Date().getTime();\n\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\tvar id = $timeout(function() {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\t\tlastTime = currTime + timeToCall;\n\t\treturn id;\n\t};\n\n\treturn polyfill('requestAnimationFrame', fallback);\n}\n\n/* @ngInject */\nfunction cancelAnimation (polyfill, $timeout) {\n\tvar fallback = function(promise) {\n\t\t$timeout.cancel(promise);\n\t};\n\n\treturn polyfill('cancelAnimationFrame', fallback);\n}\n\n})();\n"],"sourceRoot":"/source/"}